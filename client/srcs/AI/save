// moves.clear();
float x = this->my_player->transform.position.x;
float y = this->my_player->transform.position.z;



if (this->select_t == false) {
	this->get_target(x, y, dynamic_cast<GameScene*>(BombermanClient::instance->current_scene)->all_player);
} else {
	this->target.pos_x = x;
	this->target.pos_y = y;
}

if (this->select_t == false)
	return (0);

if (moves.size() > 0) {
	float t = SPEED; // Tolerance

	int nx = moves.front().pos_x;
	int ny = moves.front().pos_y;
	//If current target close delete them
	if (x >= nx - t && x <= nx + t && y >= ny - t && y <= ny + t) {
		moves.pop_front();
	} else {

	}
} else if (this->a_star.path_finding(x, y, this->target, moves)) {
	std::cout << "New Destination !" << std::endl;
	if (moves.size() > 0)
		moves.pop_front();
	for (auto elem : moves) {
		std::cout << "-x " << elem.pos_x << " -y " << elem.pos_y <<  std::endl;
	}
}

if (moves.size() > 0) {
	int nx = moves.front().pos_x;
	int ny = moves.front().pos_y;

	if (x <= nx && (abs(x - nx) > SPEED))
		return(SDL_SCANCODE_UP);
	if (x > nx && (abs(x - nx) > SPEED))
		return(SDL_SCANCODE_DOWN);
	if (y > ny && (abs(y - ny) > SPEED))
		return(SDL_SCANCODE_LEFT);
	if (y < ny && (abs(y - ny) > SPEED))
		return(SDL_SCANCODE_RIGHT);
}
return (0);
